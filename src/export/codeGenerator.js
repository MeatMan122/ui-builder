/**
 * Generates a self-contained Phaser factory function from the editor state.
 */

export function generateCode(componentName, elements, groups) {
  const safeName = componentName || 'MyUIComponent';
  const fnName = `create${safeName}`;
  const preloadName = `preload${safeName}`;

  // Collect unique textures â€” use short filename-based keys for readable output
  const textures = new Map();
  const shortKeyByTexture = new Map();
  const usedShortKeys = new Set();
  for (const el of elements) {
    if (el.type === 'text') continue;
    if (!textures.has(el.textureKey)) {
      const fileName = basename(el.filePath || el.fileName);
      let shortKey = sanitizeVarName(fileName);
      if (usedShortKeys.has(shortKey)) {
        shortKey = `${shortKey}_${usedShortKeys.size}`;
      }
      usedShortKeys.add(shortKey);
      textures.set(el.textureKey, { key: shortKey, file: fileName });
      shortKeyByTexture.set(el.textureKey, shortKey);
    }
  }

  const lines = [];

  lines.push('/**');
  lines.push(` * ${safeName} - Generated by Phaser UI Builder`);
  lines.push(' *');
  lines.push(' * Usage:');
  lines.push(` *   In preload: ${preloadName}(this);`);
  lines.push(` *   In create:  const component = ${fnName}(this, x, y);`);
  lines.push(' */');
  lines.push('');

  // Preload function
  lines.push(`function ${preloadName}(scene) {`);
  for (const [, tex] of textures) {
    lines.push(`  scene.load.image('${tex.key}', '${tex.file}');`);
  }
  lines.push('}');
  lines.push('');

  // Factory function
  lines.push(`function ${fnName}(scene, x, y) {`);
  lines.push('  const container = scene.add.container(x, y);');
  lines.push('');

  // Track element variable names for reference (detect duplicates)
  const usedVarNames = new Set();
  const varNameById = new Map();
  let varIdx = 0;

  for (const el of elements) {
    let varName = sanitizeVarName(el.name || el.fileName || `element${varIdx}`);
    if (usedVarNames.has(varName)) {
      varName = `${varName}_${varIdx}`;
    }
    usedVarNames.add(varName);
    varNameById.set(el.id, varName);
    const uniqueVar = varName;
    varIdx++;

    const relX = el.x;
    const relY = el.y;

    if (el.type === 'text') {
      // Build style object inline
      const styleParts = [];
      styleParts.push(`fontFamily: '${el.fontFamily || 'Arial'}'`);
      styleParts.push(`fontSize: '${el.fontSize || 24}px'`);
      if (el.fontStyle) styleParts.push(`fontStyle: '${el.fontStyle}'`);
      styleParts.push(`color: '${el.color || '#ffffff'}'`);
      if (el.align && el.align !== 'left') styleParts.push(`align: '${el.align}'`);
      if (el.wordWrapWidth > 0) styleParts.push(`wordWrap: { width: ${el.wordWrapWidth}, useAdvancedWrap: true }`);
      if (el.stroke && el.strokeThickness > 0) {
        styleParts.push(`stroke: '${el.stroke}'`);
        styleParts.push(`strokeThickness: ${el.strokeThickness}`);
      }
      if (el.lineSpacing) styleParts.push(`lineSpacing: ${el.lineSpacing}`);
      if (el.letterSpacing) styleParts.push(`letterSpacing: ${el.letterSpacing}`);
      if (el.padding > 0) {
        const p = el.padding;
        styleParts.push(`padding: { left: ${p}, right: ${p}, top: ${p}, bottom: ${p} }`);
      }

      const escapedText = (el.text || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n');
      lines.push(`  const ${uniqueVar} = scene.add.text(${relX}, ${relY}, '${escapedText}', {`);
      for (let si = 0; si < styleParts.length; si++) {
        lines.push(`    ${styleParts[si]},`);
      }
      lines.push(`  });`);
      lines.push(`  ${uniqueVar}.setOrigin(0, 0);`);
    } else if (el.nineSlice) {
      const ns = el.nineSlice;
      const texKey = shortKeyByTexture.get(el.textureKey) || el.textureKey;
      lines.push(`  const ${uniqueVar} = scene.add.nineslice(`);
      lines.push(`    ${relX}, ${relY},`);
      lines.push(`    '${texKey}', null,`);
      lines.push(`    ${el.w}, ${el.h},`);
      lines.push(`    ${ns.left}, ${ns.right}, ${ns.top}, ${ns.bottom}`);
      lines.push(`  );`);
      lines.push(`  ${uniqueVar}.setOrigin(0, 0);`);
    } else {
      const texKey = shortKeyByTexture.get(el.textureKey) || el.textureKey;
      lines.push(`  const ${uniqueVar} = scene.add.image(${relX}, ${relY}, '${texKey}');`);
      lines.push(`  ${uniqueVar}.setOrigin(0, 0);`);
      if (el.w !== el.originW || el.h !== el.originH) {
        lines.push(`  ${uniqueVar}.setDisplaySize(${el.w}, ${el.h});`);
      }
    }

    if (el.rotation) {
      lines.push(`  ${uniqueVar}.setAngle(${el.rotation});`);
    }

    lines.push(`  container.add(${uniqueVar});`);

    // Interactive handlers
    if (el.interactive) {
      lines.push('');
      lines.push(`  ${uniqueVar}.setInteractive();`);
      const trigger = el.interactionTrigger || 'hover';

      if (trigger === 'hover' || trigger === 'both') {
        lines.push(`  ${uniqueVar}.on('pointerover', () => {`);
        if (el.animation && el.animation.trigger === 'hover-in') {
          generateTweenCode(lines, uniqueVar, el.animation, '    ');
        }
        lines.push(`    // Add hover-in behavior here`);
        lines.push(`  });`);
        lines.push(`  ${uniqueVar}.on('pointerout', () => {`);
        if (el.animation && el.animation.trigger === 'hover-out') {
          generateTweenCode(lines, uniqueVar, el.animation, '    ');
        }
        lines.push(`    // Add hover-out behavior here`);
        lines.push(`  });`);
      }

      if (trigger === 'click' || trigger === 'both') {
        lines.push(`  ${uniqueVar}.on('pointerdown', () => {`);
        if (el.animation && el.animation.trigger === 'click') {
          generateTweenCode(lines, uniqueVar, el.animation, '    ');
        }
        lines.push(`    // Add click behavior here`);
        lines.push(`  });`);
      }
    }

    lines.push('');
  }

  lines.push('  return container;');
  lines.push('}');

  return lines.join('\n');
}

function generateTweenCode(lines, varName, animation, indent) {
  if (animation.type === 'slide') {
    const { direction, distance, duration, ease } = animation.config;
    const prop = direction === 'left' || direction === 'right' ? 'x' : 'y';
    const sign = direction === 'right' || direction === 'down' ? '+' : '-';
    lines.push(`${indent}scene.tweens.add({`);
    lines.push(`${indent}  targets: ${varName},`);
    lines.push(`${indent}  ${prop}: ${varName}.${prop} ${sign} ${distance},`);
    lines.push(`${indent}  duration: ${duration},`);
    lines.push(`${indent}  ease: '${ease}',`);
    lines.push(`${indent}});`);
  }
}

function basename(filePath) {
  return (filePath || '').split('/').pop().split('\\').pop() || filePath;
}

function sanitizeVarName(name) {
  return name
    .replace(/\.[^.]+$/, '')        // remove extension
    .replace(/[^a-zA-Z0-9_]/g, '_') // replace invalid chars
    .replace(/^(\d)/, '_$1')        // don't start with digit
    .replace(/_+/g, '_')            // collapse underscores
    .replace(/^_|_$/g, '')          // trim underscores
    || 'element';
}
